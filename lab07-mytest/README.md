# Лабораторная работа №7 (mytest)

## Содержание

1. [Содержание](#содержание)
2. [Задание](#задание)
   1. [Советы](#советы)
3. [Требования к корректности решения](#требования-к-корректности-решения)
   1. [Базовые требования](#базовые-требования)
   2. [Дополнительные требования](#дополнительные-требования)
   3. [Частичные решения](#частичные-решения)
4. [Инструкция по сдаче](#инструкция-по-сдаче)
5. [Система оценки](#система-оценки)
6. [Сроки сдачи](#сроки-сдачи)

## Задание
Реализуйте библиотеку `mytest` для написания юнит-тестов вроде [doctest](https://github.com/doctest/doctest).
Должны поддерживаться макросы `TEST_CASE`, `CHECK`, `CHECK_MESSAGE` и `SUBCASE`.

Каждый `TEST_CASE` считается пройденным тогда и только тогда, когда все условия `CHECK`/`CHECK_MESSAGE`, выполненные из 
него, оказались истинны.

Библиотека состоит из:

* Заголовочного файла `mytest.hpp`, который используется пользователем библиотеки.
* Единицы трансляции `mytest.cpp`, которая всегда подключается пользователем библиотеки.
* Единицы трансляции `mytest_main.cpp` с реализацией `int main()`. Она подключается пользователем библиотеки только если 
  хочется запускать тесты.
* Заголовочного файла `mytest_internal.hpp`, который используется только для общения между собой `mytest.cpp` и 
  `mytest_main.cpp`.

Должны корректно компилироваться и компоноваться (линковаться) два вида программ, использующих `mytest`:

* Включающие единицы трансляции `mytest_main.cpp` и `mytest.cpp` — в этом случае запускаются все тесты.
* Не включающие единицу трансляции `mytest_main.cpp`, но включающие `mytest.cpp` — в этом случае должен запускаться 
  предоставленный пользователем `main()`, а весь код внутри всех `TEST_CASE` игнорируется.

Таким образом, пользователь `mytest` может писать тесты вперемешку со своим основным кодом и они не будут ему мешать.

Можно считать, что программа однопоточная.

Использовать `doctest` запрещается.

### Советы
* `clang-tidy` запрещает использовать макросы, однако они требуются в `mytest.hpp`. Также иногда возможны 
  ложноположительные срабатывания в заголовках; например, на неиспользуемые поля. Это нужно заглушить.
* Чтобы не дублировать много кода между `CHECK` и `CHECK_MESSAGE`, создайте вспомогательную функцию и гляньте на 
  `std::optional`.
* Так как автотестам требуется компилировать ваше решение, они пытаются найти компилятор при помощи 
  `detect-compiler.sh`. Если не получилось сразу, то вы можете:
  * Запустить автотесты из `Developer Command Prompt for VS 2022`, если используете только Visual Studio.
    Должен появиться компилятор `cl.exe`.
  * Скомпилировать каждый из примеров самостоятельно в файл `mytest-main` в соответствующей папке, закомментировать в 
    `run-test_data.sh` строчку с запуском `${COMPILATION_COMMAND[@]} $SOURCES` (комментарии в Bash — `#` в начале 
    строки) и запустить автотесты.
* Будьте аккуратны с именами в макросах: по возможности используйте полностью квалифицированные имена: `::mytest::foo()` 
  вместо `foo()`.
* Чтобы правильно реализовать макрос `TEST_CASE`, используйте идеи и код из упражнений `macro-execute-before-main`, 
  `static-keyword`, `siof`. Иначе может произойти коллизия имён.
* Стандарт [гарантирует](https://en.cppreference.com/w/cpp/language/constant_initialization), что если глобальная 
  переменная инициализируется константой (`int x = 10`), то это происходит во всех единицах трансляции строго до всех 
  остальных инициализаций. В частности, до вызовов всех необычных конструкторов.
* Если получаете предупреждение `cppcoreguidelines-avoid-non-const-global-variables` внутри макроса и не можете 
  заглушить — просто сделайте соответствующую переменную константной.
* Если вам надо сохранить свободную функцию или лямбда-функцию (не метод) в переменную, воспользуйтесь 
  `std::function<void()>` (если функция ничего не принимает и не возвращает).
  * Более эффективный и сложный способ для свободных функций (но не лямбд с захватами) — указатели на функции.
  * Шаблоны в этом задании не нужны.
* Чтобы реализовать вложенные `SUBCASE`, вам потребуется как-то узнать о завершении подтеста. Для этого вы можете 
  создать внутри `for`/`while` (или даже `if`, начиная с C++17) временную переменную с __деструктором__ — специальной 
  функцией, которая вызывается при удалении переменной:
  ```c++
  struct Foo {
      Foo() { std::cout << "Created!\n"; }
      ~Foo() { std::cout << "Destroyed!\n"; }
      // Требуется для clang-tidy
      Foo(const Foo &) = delete;
      Foo(Foo &&) = delete;
      Foo &operator=(const Foo &) = delete;
      Foo &operator=(Foo &&) = delete;
  };
  // ...
  if (Foo f; 2 * 2 == 4) {  // Created!
      std::cout << "inside\n";
  }  // Destroyed!
  ```
* При реализации `SUBCASE` вы не сможете сначала сохранить иерархию куда-то, а потом выполнять. Вам надо с первого же 
  запуска `TEST_CASE` начать одновременно выполнять правильный первый `SUBCASE` и понимать, что делать дальше.
* К сожалению, Visual Studio может не обработать конструкцию `[[maybe_unused]] ::mytest::Foo foo;`. Можно переписать: 
  `::mytest::Foo foo [[maybe_unused]];`.
* Вы можете попробовать понять, что происходит в doctest. Рекомендуется пользоваться отладчиком или хотя бы средой 
  разработки, чтобы можно было ходить по определениям.
* Если вам кажется, что с макросами происходит что-то странное — запустите только препроцессор, чтобы посмотреть,
  во что они раскрываются в каждой единице трансляции.
  * Ключ `-E` для gcc/clang.
  * Ключ `/P` для Visual Studio, в GUI называется `Preprocess to a file`.

## Требования к корректности решения
### Базовые требования
Действуют [стандартные требования](../common/common-requirements.md), но:

* Максимальное суммарное количество строк (включая пустые) в файлах `.hpp` и `.cpp` — 400.
  Полное авторское решение занимает 245.

### Дополнительные требования
* Все определения должны быть по максимуму вынесены в `mytest_main.cpp` и в `mytest.cpp`.
* В `mytest.hpp` остаётся только самый минимум, который нужен пользователю библиотеки.
  Общие для `mytest.cpp`/`mytest_main.cpp` объявления можно вынести в `mytest_internal.hpp`.
* Любые `*.cpp` запрещено инклудить в другие.
* `mytest_internal.hpp` запрещено инклудить в пользовательскую программу даже косвенно.
  В частности, запрещено инклудить в `mytest.h`.
* Все сущности библиотеки должны находиться внутри пространства имён `::mytest`.
* Так как макросы не могут находиться внутри пространства имён, все внутренние для библиотеки
  макросы должны начинаться с `MYTEST_INTERNAL_`.
* Имена всех сущностей, генерируемых макросами, должны начинаться с `mytest_`.
* Запрещается использовать `__COUNTER__` — это нестандартное расширение.
  Можно использовать `__LINE__`

### `CHECK` и `CHECK_MESSAGE`
Макрос `CHECK(expr)` вычисляет выражение `expr` ровно один раз.
Если получилось истинное значение, ничего не происходит.
Иначе в стандартный поток ошибок (`std::cerr`) выводится сообщение в следующем формате,
содержащее строковое представление `expr`, имя файла и строку,
где располагался вызов `CHECK`:

```
CHECK(2 * 2 == 5) at demo/demo1.cpp:8 failed!
```

Допускается выводить полный путь к файлу, не требуется как-то обрабатывать результат подстановки `__FILE__`.

Макрос `CHECK_MESSAGE(expr, msg)` ведёт себя аналогично, но в сообщении
об ошибке также добавляется сообщение `msg` (это строка, необязательно литерал):

```
CHECK(2 * 2 == 5) at demo/demo2.cpp:13 failed!
    message: demo2-msg2
```

Выражение `msg` тоже должно всегда вычисляться ровно один раз.

* Оба макроса должны вести себя как вызов функции, возвращающей `void`.
* Если программа компилируется в режиме запуска тестов, то оба макроса будут вызываться только при выполнении очередного `TEST_CASE`.
* Если программа компилируется в режиме запуска пользовательского `main()`, то оба макроса могут вызываться вне выполнений `TEST_CASE`.
  * [Extra reading](https://github.com/Nekrolm/ubbook/blob/master/runtime/static_initialization_order_fiasco.md#initialization-order-fiasco-%D0%B8-%D0%BD%D0%B5%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D0%BC%D1%8B%D0%B5-%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BA%D0%B8): при этом гарантируется, что стандартный ввод-вывод будет проинициализирован до вызова макроса.
* Ни один макрос никогда не прерывает выполнение программы.

### `TEST_CASE`
После макроса `TEST_CASE(name)` обязательно идут фигурные скобки с текстом теста.
Он может встретиться только там, где может встретиться определение свободной функции.

* `name` — произвольный строковой литерал.
* Фреймворк не должен требовать от пользователя как-то определять тесты, кроме как `TEST_CASE`.
* `TEST_CASE` может вызывать произвольные функции, которые могут пользоваться любыми другими макросами фреймворка.
* В одной строчке файла не может встретиться два `TEST_CASE`.
* Тесты должны выполняться в лексикографическом порядке: отсортированы по имени теста.
  При совпадении имён порядок произвольный.
* Если тесты пройдены, `mytest_main.cpp` должен завершаться с нулевым кодом возврата, иначе — с кодом возврата 1.

Перед началом тестирования каждого теста в стандартный поток ошибок выводится сообщение
с именем теста:

```
Running "Demo1.cpp test case 1"...
```

После окончания всех тестов выводится статистика по количеству пройденных и запущенных тестов:

```
===== Tests passed: 2/5 =====
```

### `SUBCASE`
Внутри `TEST_CASE` можно выделять несколько блоков `SUBCASE(name)`, в том числе вложенных,
в том числе внутри функций, которые вызывает `TEST_CASE`.
Выполняются почти [так же, как и в `doctest`](https://github.com/doctest/doctest/blob/86892fc480f80fb57d9a3926cb506c0e974489d8/doc/markdown/tutorial.md#test-cases-and-subcases).

* Трактуем `SUBCASE(name)` как предложение (statement) вроде `if`/`for`, причём
  после него гарантированно идут фигурные скобки с телом подслучая.
* `name` — произвольная строка. Необязательно литерал, может генерироваться динамически.
* В одной строчке файла не может встретиться два `SUBCASE`.
* Можно считать, что максимальная вложенность `SUBCASE` небольшая.

Неформально говоря, мы хотим запустить `TEST_CASE` столько раз, сколько там существует самых глубоких подслучаев.
При каждом запуске обрабатывается новый подслучай.

Более формально, блоки `SUBCASE` выполняются следующим образом.

1. Строится упорядоченный список `X` из `SUBCASE`, внутри которых нет других `SUBCASE`.
   Порядок — как при выполнении программы.
   Например, цикл может сгенерировать несколько разных `SUBCASE`.
2. Каждый случай `x` из `X` выполняется, причём при выполнении случая `x`
   также выполняются те, в которые он вложен.
   * Между запусками случаев выводите в стандартный поток ошибок сообщение:
     ```
     ...another subcase...
     ```
3. Если в какой-то момент `CHECK`/`CHECK_MESSAGE` выдали ошибку,
   то текущий случай обрабатывается до конца, а вот следующие случаи из списка `X` не выполняются.

Например, в следующем коде:

```c++
TEST_CASE("Subcase test") {
    std::cerr << "1";
    SUBCASE("a") {
        std::cerr << "2";
        SUBCASE("b") {
            std::cerr << "3";
        }
        SUBCASE("c") {
            std::cerr << "4";
        }
        std::cerr << "5";
    }
    std::cerr << "6";
    SUBCASE("d") {
        std::cerr << "7";
        SUBCASE("e") {
            std::cerr << "8";
        }
        SUBCASE("f") {
            std::cerr << "9";
        }
    }
    std::cerr << "end\n";
}
```

будет построен список `X` из `SUBCASE("b")`, `SUBCASE("c")`, `SUBCASE("e")`, `SUBCASE("f")`.
При выполнении каждого из них также запустится окружающий код `SUBCASE("a")` или `SUBCASE("d")`.
На экран выведется `12356end` для первого (`a`, `b`), `12456end` для второго (`a`, `c`),
`1678end` для третьего (`d`, `e`) и `1679end` для четвёртого (`d`, `f`).

А если в примере выше после `std::cerr << "2"` добавить `CHECK(false)`,
то будет запущен только один подслучай (`a`, `b`) и на экран выведется `12356end`.

Также `CHECK` и `CHECK_MESSAGE` при ошибке должны выводить на экран и
путь до самого вложенного из выполненных в текущем запуске `SUBCASE`, например:

```
CHECK(false) at subcases.cpp:14 failed!
    message: msg2
    in subcase a
    in subcase b
```

Это нужно, чтобы можно было писать примерно такие тесты:
```c++
TEST_CASE("check bigint") {
    // Исходная настройка (arrange)
    bigint a = 25;
    bigint b = 10;
    // Разные действия (act) и проверка результата (assert)
    SUBCASE("+=") {
        a += b;
        CHECK(a == 35);
    }
    SUBCASE("-=") {
        a -= b;
        CHECK(a == 15);
    }
    // Общая для всех случаев проверка (assert), зависит от того,
    // какой SUBCASE был выполнен перед этим.
    CHECK(b == 10);
}
```

В этом примере тест `check bigint` запустится дважды.
В первый раз он создаст новые переменные `a = 25`, `b = 10`, зайдёт в подслучай `+=`, вызовет `+=`, а в конце проверит, что `b == 10`.
Во второй раз он снова создаст новые переменные `a = 25`, `b = 10`, зайдёт в подслучай `-=`, вызовет `-=`, а в конце проверит, что `b == 10`.
Таким образом, _не требуется_ как-либо запоминать состояние программы в начале `SUBCASE`,
это происходит само собой: `TEST_CASE` запускается каждый раз с нуля.

Если же выполнение ещё не дошло до самого вложенного `SUBCASE` (то есть до элемента списка `X`),
то выводится лишь префикс сообщений `in subcase`.

Обратите внимание, что имена `SUBCASE` вообще никак не влияют на выполнение
и могут хоть все равняться пустым строкам.

Можно считать, что то, какие `SUBCASE` будут выполняться при запуске `TEST_CASE`,
зависит только от действий вашего фреймворка.
Например, положить `SUBCASE` в `if` можно, но изменяемых глобальных переменных
в условии такого `if` не будет.

### Частичные решения
Вы можете реализовать любой префикс из пяти подзаданий ниже и получить частичные баллы.

1. Только макросы `CHECK` и `CHECK_MESSAGE`.
   Гарантируется, что единица трансляции `mytest_main.cpp` не участвует в компиляции.
2. Добавляется макрос `TEST_CASE`.
   Гарантируется, что программа либо подходит под первое подзадание,
   либо в ней участвует единица трансляции `mytest_main.cpp`.
   В последнем случае макрос `TEST_CASE` вызывается не более чем в одной единице трансляции.
   Более того, все вызовы `TEST_CASE` отсортированы по имени.
3. Теперь программа может содержать любое количество единиц трансляции с `TEST_CASE`,
   независимо от того, участвует ли `mytest_main.cpp` в компиляции.
4. Добавляется макрос `SUBCASE`, однако `SUBCASE` не могут вкладываться друг в друга.
5. Ограничения отсутствуют.

## Инструкция по сдаче
[Схема стандартная](../common/common-requirements.md#формат-сдачи): вы должны выполнить
задание в отдельной ветке и создать Pull Request.
В этом задании должно хватить веб-интерфейса GitHub, если возникают проблемы — попросите практика помочь.

Если вы хотите сдать только некоторые части задания, удалите остальные тесты из `tests.txt`.

## Система оценки
[Схема стандартная](../common/common-requirements.md#система-оценки), баллы:

| Выполненные части | Макс. корректность | Макс. стиль | Макс. итог |
|-------------------|--------------------|-------------|------------|
| 1                 | 1                  | 1           | 2          |
| 1-2               | 3                  | 2           | 5          |
| 1-3               | 4                  | 3           | 7          |
| 1-4               | 5                  | 4           | 9          |
| 1-5               | 7                  | 5           | 12         |

Баллы свыше 10 в этом задании считаются бонусными.
Вы их набрать можете, а Идеалов Идеал Идеалович — нет.
Итоговая оценка за практику всё ещё не превышает 10.

## Сроки сдачи
Задание выдано 9 июня 2023 (пятница).
Ниже в каждом случае указано кипрское время (_Asia/Nicosia_).

* **Дедлайн сдачи:** 16 июня (пятница), **22**:59.
* Ожидаемый срок проверки: 23 июня (пятница).
* Если первая попытка сдачи достаточно разумна (на усмотрение принимающего),
  то вы можете сделать ещё попытку исправлений или даже несколько.
    * Предложение актуально даже если вы получили автоматический ноль за первую попытку.
    * Выставляется максимум из всех попыток.
* **Срок исправлений**: **30** июня (пятница), **22**:59.
