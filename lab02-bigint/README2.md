# Лабораторная работа №2 (bigint)

## Содержание

1. [Содержание](#содержание)
2. [Задание](#задание)
   1. [Советы](#советы)
3. [Требования к корректности решения](#требования-к-корректности-решения)
   1. [Базовые требования](#базовые-требования)
   2. [Дополнительные требования](#дополнительные-требования)
   3. [Частичные решения](#частичные-решения)
4. [Инструкция по сдаче](#инструкция-по-сдаче)
5. [Система оценки](#система-оценки)
6. [Сроки сдачи](#сроки-сдачи)

## Задание

Реализуйте «длинную арифметику», то есть класс (структуру), хранящий внутри себя числа произвольной
длины и поддерживающий базовые арифметические операции с ними. Для упрощения реализации, нужно
поддержать только беззнаковую целочисленную арифметику, то есть поддерживаются только
неотрицательные числа.

Решение должно быть оформлено в виде класса `bigint`. Вы можете реализовать только часть операций
или пользоваться дополнительными предположениями, смотри [частичные решения](#частичные-решения).

Для удобства работы и тестирования `bigint` должен уметь конструироваться из строки и из числа типа
`unsigned int`. Весь остальной зоопарк целочисленных типов можно не реализовывать.

```C++
bigint x("179"), y(57);  // Создаёт числа 179 и 57, соответственно.
```

Числа нужно уметь сравнивать между собой, а также с числами типа `unsigned int`. Можно не
поддерживать другие целочисленные типы, в том числе `int` и `unsigned long long`.

```C++
bigint x("179"), y("57");
std::cout << std::boolalpha
          << (x == y) << " "
          << (x != 57) << " "
          << (179 < y) << " "
          << (y >= x) << std::endl;  // Должен вывести "false true false false".
```

Из простых арифметических действий требуется поддерживать только сложение и вычитание. Можно
считать, что в случае, если в результате вычитания получаются отрицательные числа, поведение не
определено (т.е. гарантируется, что в тестах такого не бывает). Точно так же нужно уметь складывать
и вычитать с `unsigned int`.

```C++
bigint x("179"), y("57");
std::cout << std::boolalpha
          << (x + y == bigint("236")) << " "
          << (x - 57 == bigint("122")) << " "
          << (200 - x == bigint("21")) << std::endl;  // Должен вывести "true trtue true".
```

Кроме того, нужно поддерживать операторы присваивания, в том числе `+=` и `-=`, в том числе с
аргументами типа `unsigned int`.

```C++
bigint x("179"), y("57");
x += y;
x -= 57;
y += 122;
std::cout << std::boolalpha << (x == y) << std::endl;  // Должен вывести "true".
```

Также требуется поддерживать постфиксные и префиксные инкременты и декременты (все четыре
комбинации).

```C++
bigint x("179");
x++;
++x;
x--;
--x;
std::cout << std::boolalpha << (x == 179) << std::endl; // Должен вывести "true".
```

Также нужно уметь поддерживать преобразование `bigint` в строки (для чего нужно реализовать метод
`to_string()`, возвращающий `std::string`), ввод и вывод. При реализации ввода можно рассчитывать на
то, что ввод всегда будет корректный (то есть гарантируется, что в тестах не бывает иначе).

```C++
bigint x("179");
std::cout << x.to_string() << std::endl;  // Должен вывести "179" (без кавычек).
std::cout << x << std::endl;  // Должен вывести "179" (без кавычек).
bigint y;
std::cin >> y;  // Должен прочитать число со стандартного ввода.
```

### Советы

* При реализации всегда помните про ведущие нули.
* Храните цифры в векторе, а не строчке — так и проще поддержать произвольное основание системы
  счисления, и в коде меньше лишних операций вроде `- '0'` и `+ '0'`.
* Возможно, для реализации сложения и вычитания в столбик окажется проще хранить числа в
  перевёрнутом виде (то есть первый элемент вектора — младшая цифра числа).
* Реализуйте бинарные операторы как функции вне класса, а не как методы.
  * В таком случае при наличии конструктора от `unsigned int` при вызове `2 + bigint("123")`
    сработает неявное преобразование и перегрузка `operator+(const bigint&, const bigint&)`
    подойдёт.
  * Это позволяет избежать дублирования кода.
  * При необходимости пользуйтесь `friend`.
* Реализовывать `operator=` не надо — в правильной реализации вас устроит его стандартное поведение:
  присваивать каждое поле по отдельности.
  * А конструкции вида `a = 10` должны успешно работать через неявное преобразование числа к
    `bigint`.
* Начиная с C++17 вы можете создать константу, которая вычисляется из других констант хитрым
  образом, при помощи [IIFE](https://www.cppstories.com/2016/11/iife-for-complex-initialization/)
  (immediately invoked function expression):
  ```c++
  const int FIB_10 = []() {
      int a = 0, b = 1;
      for (int i = 0; i < 10; i++) {
          int c = a + b;
          a = b;
          b = c;
      }
      return a;
  }();  // Созданное лямбда-выражение сразу вызывается
  // Теперь FIB_10 равно 55.
  ```
* Если у вас возникают проблемы с алгоритмической частью (сложение, вычитание) — обращайтесь к
  практикам по C++ или алгоритмам.
* Перегрузки `operator>>` и `operator<<` принимают слева и возвращают не `std::stringstream&`,
  а `std::istream&` (для чтения) и `std::ostream&` (для вывода).
  Эти типы — обобщение всех потоков вводы/вывода, соответственно.
  * Считайте, что ввод всегда корректен и число отделено пробельными символами или концом потока.
    Иначе придётся аккуратно эмулировать семантику `int`, считывать почти посимвольно, разбираться с
    обработкой ошибок ввода, [`sentry`-объектом][cppreference-sentry]. Это муторно и специфично,
    хотя и необходимо для корректной перегрузки.
  * Extra reading: [баг то ли в компиляторе, то ли на cppreference](https://stackoverflow.com/questions/69320918/why-does-taking-istream-to-a-temporary-stringstream-works-but-not-when-tak),
    спасибо Марку Ипатову за вопрос.
* В тестах вы можете встретить строку `(a++) = 10` — она увеличивает `a`, возвращает старое значение
  `a` и пытается записать в _старое значение_ `a` число `10`. Это бессмысленная операция: например,
  для встроенных типов вроде `int` такой код компилироваться не будет. Но в вашем решении такой код
  автоматически будет компилироваться, запрещать это мы пока не умеем.
* Если вы заведёте константное поле — станет невозможно копировать объекты, отключится `operator=`.
  Константы лучше завести на верхнем уровне, рядом с `BASE`.

## Требования к корректности решения

### Базовые требования

Действуют [стандартные требования](../common/common-requirements.md).

Начиная с этого задания на файлах с тестами для `doctest` для `clang-tidy` отключена
проверка `readability-function-cognitive-complexity`.

Также начиная с этого задания следует помечать некоторые функции `[[nodiscard]]`, а некоторые
конструкторы и операторы преобразования — `explicit`.

### Дополнительные требования

* Длинное число должно храниться в динамическом массиве по цифрам в системе счисления
  с основанием `BASE`.
  * Константа `BASE` должна задаваться в начале файла `bigint.inc.cpp` ровно как в заглушке.
    Можно дописать перед ней какие-то `#include`.
  * `BASE` всегда является степенью десятки, строго большей единицы.
  * Гарантируется, что числа `-2 * BASE` и `2 * BASE` помещаются в `int`.
  * Значение `BASE` не влияет на ввод и вывод: они всегда десятичные. То есть при изменении `BASE`
    тесты менять не нужно. Например, при `BASE == 1000` конструктор `bigint(12345678)` создаст
    `bigint`, хранящий цифры `12`, `345`, `678` (в порядке на вашем усмотрении), а при `BASE == 10`
    — все восемь десятичных цифр отдельно.
    При выводе или преобразовании `bigint` в строку или число снова получается `12345678`.
  * Ваше решение должно автоматически подстраиваться, если изменить только `BASE`.
    В частности, нельзя создавать другие константы, которые надо вручную изменить при изменении
    `BASE`.
* Семантика всех операций должна быть как можно ближе к `unsigned int`.
* Каждая операция с числом должна быть как можно эффективнее: сначала важна асимптотика,
  потом важно количество (пере)выделений памяти (в том числе внутри `vector`, `string`,
  `stringstream`), затем всё остальное.
  * При этом считаем, что выделение вектора размера O(1) бесплатно.
    Этого можно добиться при
    помощи [boost::small_vector](https://www.boost.org/doc/libs/1_77_0/doc/html/boost/container/small_vector.html) или
    его аналога вместо `std::vector`, но вам это делать не требуется.

### Частичные решения

Вы можете реализовать любой префикс из шести подзаданий ниже и получить частичные баллы.

Если ваше решения не работает при `BASE != 10`, вы получаете не больше половины баллов.
Если ваше решение ломается при появлении ведущих нулей, а они разрешены, то вы получаете не больше
половины баллов. Акции объединяются: если решение не работает ни с `BASE != 10`, ни с ведущими
нулями, вы не можете получить за задание больше 2.5/10.

1. Реализуйте:
  * Конструктор `bigint` по умолчанию (инициализирует в ноль).
  * Конструирование `bigint` от непустой строки из цифр и от `unsigned int`.
     Ведущие нули запрещены, кроме строки `"0"`.
   * Шесть операторов для сравнения чисел.
     Они должны работать, в том числе, в выражениях со смешением `bigint` и `unsigned int`.
   * Метод `to_string()`, преобразовывающий число в строку.
2. Реализуйте оператор явного (explicit) преобразования в `unsigned int`.
   Также с этого момента разрешаются ведущие нули во входных данных, в выходных данных ведущие нули
   запрещены.
3. Реализуйте операторы `+` и `+=`.
4. Реализуйте операторы `-` и `-=`.
5. Реализуйте постфиксные и префиксные унарные операторы `++` и `--`.
6. Реализуйте операторы `<<` и `>>` для ввода-вывода.

## Инструкция по сдаче

[Схема стандартная](../common/common-requirements.md#формат-сдачи): вы должны выполнить
задание в отдельной ветке вашего уже существующего репозитория и создать Pull Request (не нужно
делать _fork_). В этом задании должно хватить веб-интерфейса GitHub, если возникают проблемы —
попросите практика помочь.

Если вы хотите сдать только некоторые части задания, закомментируйте строки вида `#define TEST_9`
для остальных частей в файле `tests.cpp`, чтобы отключить соответствующие автотесты.

## Система оценки

* Задание оценивается в 10 баллов: 6 за корректность, 4 за стиль.
  * Если не проходит хотя бы одна автопроверка или неверно назван PR, вы получаете ноль.
  * Вы не можете получить за стиль больше баллов, чем за корректность.
* Вы можете сдать любой префикс частей:

  | Выполненные части | Макс. корректность | Макс. стиль | Макс. итог |
  |-------------------|--------------------|-------------|------------|
  | 1                 | 1                  | 1           | 2          |
  | 1-2               | 1.5                | 1.5         | 3          |
  | 1-3               | 2.5                | 2.5         | 5          |
  | 1-4               | 3.5                | 3           | 7          |
  | 1-5               | 5                  | 4           | 9          |
  | 1-6               | 6                  | 4           | 10         |

## Сроки сдачи

Задание выдано 2 марта 2023 (четверг).
Ниже в каждом случае указано кипрское время (_Asia/Nicosia_).

* **Дедлайн сдачи:** 12 марта 2023 (воскресенье), **22**:59.
* Ожидаемый срок проверки: 19 марта (воскресенье).
* Если первая попытка сдачи достаточно разумна (на усмотрение принимающего),
  то вы можете сделать ещё попытку исправлений или даже несколько.
    * Предложение актуально даже если вы получили автоматический ноль за первую попытку.
    * Выставляется максимум из всех попыток.
* **Срок исправлений**: 26 марта 2021 (воскресенье), **22**:59.

[cppreference-sentry]: https://en.cppreference.com/w/cpp/io/basic_istream/sentry
